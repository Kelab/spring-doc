## 4. WebSockets

[WebFlux](https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-websocket)

参考文档的此部分涵盖对Servlet堆栈的支持，包括原始WebSocket交互的WebSocket消息传递，通过SockJS进行WebSocket仿真以及通过STOMP作为WebSocket的子协议进行发布-订阅消息传递。

### 4.1。WebSocket介绍

WebSocket协议[RFC 6455](https://tools.ietf.org/html/rfc6455)提供了一种标准化的方法，可以通过单个TCP连接在客户端和服务器之间建立全双工的双向通信通道。它是与HTTP不同的TCP协议，但旨在通过端口80和443在HTTP上工作，并允许重复使用现有的防火墙规则。

WebSocket交互始于一个HTTP请求，该请求使用HTTP`Upgrade`标头进行升级，或者在这种情况下切换到WebSocket协议。以下示例显示了这种交互：

```yaml
GET /spring-websocket-portfolio/portfolio HTTP/1.1
Host: localhost:8080
Upgrade: websocket 
Connection: Upgrade 
Sec-WebSocket-Key: Uc9l9TMkWGbHFD2qnFHltg==
Sec-WebSocket-Protocol: v10.stomp, v11.stomp
Sec-WebSocket-Version: 13
Origin: http://localhost:8080
```

1. 该`Upgrade`头。
2. 使用`Upgrade`连接。

具有WebSocket支持的服务器代替通常的200状态代码，返回类似于以下内容的输出：

``` yaml
HTTP/1.1 101 Switching Protocols 
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: 1qVdfYHU9hPOl4JYYNXF623Gzn0=
Sec-WebSocket-Protocol: v10.stomp
```

1. 协议切换

成功握手后，HTTP升级请求的基础TCP套接字将保持打开状态，客户端和服务器均可继续发送和接收消息。

WebSockets的工作原理的完整介绍超出了本文档的范围。请参阅RFC 6455，HTML5的WebSocket章节，或Web上的许多简介和教程中的任何一个。

请注意，如果WebSocket服务器在Web服务器（例如nginx）后面运行，则可能需要对其进行配置，以将WebSocket升级请求传递到WebSocket服务器。同样，如果应用程序在云环境中运行，请检查与WebSocket支持相关的云提供商的说明。

#### 4.1.1。HTTP与WebSocket

尽管WebSocket被设计为与HTTP兼容并以HTTP请求开头，但重要的是要了解这两个协议导致了截然不同的体系结构和应用程序编程模型。

在HTTP和REST中，应用程序被建模为许多URL。为了与应用程序交互，客户端访问那些URL，即请求-响应样式。服务器根据HTTP URL，方法和标头将请求路由到适当的处理程序。

相比之下，在WebSockets中，初始连接通常只有一个URL。随后，所有应用程序消息都在同一TCP连接上流动。这指向了一个完全不同的异步，事件驱动的消息传递体系结构。

WebSocket也是一种低级传输协议，与HTTP不同，它不对消息的内容规定任何语义。这意味着除非客户端和服务器就消息语义达成一致，否则就无法路由或处理消息。

WebSocket客户端和服务器可以通过`Sec-WebSocket-Protocol`HTTP握手请求上的标头来协商更高级别的消息传递协议（例如STOMP）的使用。在这种情况下，他们需要提出自己的约定。

#### 4.1.2。何时使用WebSockets

WebSockets可以使网页具有动态性和交互性。但是，在许多情况下，结合使用Ajax和HTTP流或长时间轮询可以提供一种简单有效的解决方案。

例如，新闻，邮件和社交订阅源需要动态更新，但是每几分钟进行一次更新可能是完全可以的。另一方面，协作，游戏和金融应用程序需要更接近实时。

仅延迟并不是决定因素。如果消息量相对较少（例如，监视网络故障），则HTTP流或轮询可以提供有效的解决方案。低延迟，高频率和高音量的结合才是使用WebSocket的最佳案例。

还要记住，在Internet上，控件之外的限制性代理可能会阻止WebSocket交互，这可能是因为未将它们配置为传递 `Upgrade`标头，或者是因为它们关闭了长期处于空闲状态的连接。这意味着与面向公众的应用程序相比，将WebSocket用于防火墙内部的应用程序是一个更直接的决定。

### 4.2。WebSocket API

[WebFlux](https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-websocket-server)

Spring框架提供了一个WebSocket API，可用于编写处理WebSocket消息的客户端和服务器端应用程序。

#### 4.2.1. `WebSocketHandler`

[WebFlux](https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-websocket-server-handler)

创建WebSocket服务器就像实现一样简单，`WebSocketHandler`或者更可能继承`TextWebSocketHandler`或`BinaryWebSocketHandler`。以下示例使用`TextWebSocketHandler`：

~~~ java
import org.springframework.web.socket.WebSocketHandler;
import org.springframework.web.socket.WebSocketSession;
import org.springframework.web.socket.TextMessage;

public class MyHandler extends TextWebSocketHandler {

    @Override
    public void handleTextMessage(WebSocketSession session, TextMessage message) {
        // ...
    }

}
~~~

有专用的WebSocket Java配置和XML名称空间支持，用于将前面的WebSocket处理程序映射到特定的URL，如以下示例所示：

``` java
import org.springframework.web.socket.config.annotation.EnableWebSocket;
import org.springframework.web.socket.config.annotation.WebSocketConfigurer;
import org.springframework.web.socket.config.annotation.WebSocketHandlerRegistry;

@Configuration
@EnableWebSocket
public class WebSocketConfig implements WebSocketConfigurer {

    @Override
    public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) {
        registry.addHandler(myHandler(), "/myHandler");
    }

    @Bean
    public WebSocketHandler myHandler() {
        return new MyHandler();
    }

}
```

以下示例显示了与先前示例等效的XML配置：

``` xml
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:websocket="http://www.springframework.org/schema/websocket"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/websocket
        https://www.springframework.org/schema/websocket/spring-websocket.xsd">

    <websocket:handlers>
        <websocket:mapping path="/myHandler" handler="myHandler"/>
    </websocket:handlers>

    <bean id="myHandler" class="org.springframework.samples.MyHandler"/>

</beans>
```

前面的示例用于Spring MVC应用程序，并且应包含在的配置中[`DispatcherServlet`](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-servlet)。但是，Spring的WebSocket支持不依赖于Spring MVC。在`WebSocketHandler`的帮助下，[`WebSocketHttpRequestHandler`](https://docs.spring.io/spring-framework/docs/5.3.1/javadoc-api/org/springframework/web/socket/server/support/WebSocketHttpRequestHandler.html)。将a集成到其他HTTP服务环境中 相对简单

当`WebSocketHandler`直接使用API或间接使用API（例如通过 [STOMP](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#websocket-stomp)消息传递）时，由于基础标准WebSocket会话（JSR-356）不允许并发发送，因此应用程序必须同步消息的发送。一种选择是用[`ConcurrentWebSocketSessionDecorator`](https://docs.spring.io/spring-framework/docs/5.3.1/javadoc-api/org/springframework/web/socket/handler/ConcurrentWebSocketSessionDecorator.html)将包裹`WebSocketSession`起来 。

#### 4.2.2. WebSocket Handshake

[WebFlux](https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-websocket-server-handshake)

定制初始HTTP WebSocket握手请求的最简单方法是通过`HandshakeInterceptor`，它公开了“握手之前”和“握手之后”的方法。您可以使用此类拦截器来阻止握手或使的任何属性可用`WebSocketSession`。以下示例使用内置的拦截器将HTTP会话属性传递到WebSocket会话：

```java
@Configuration
@EnableWebSocket
public class WebSocketConfig implements WebSocketConfigurer {

    @Override
    public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) {
        registry.addHandler(new MyHandler(), "/myHandler")
            .addInterceptors(new HttpSessionHandshakeInterceptor());
    }

}
```

以下示例显示了与先前示例等效的XML配置：

```xml
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:websocket="http://www.springframework.org/schema/websocket"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/websocket
        https://www.springframework.org/schema/websocket/spring-websocket.xsd">

    <websocket:handlers>
        <websocket:mapping path="/myHandler" handler="myHandler"/>
        <websocket:handshake-interceptors>
            <bean class="org.springframework.web.socket.server.support.HttpSessionHandshakeInterceptor"/>
        </websocket:handshake-interceptors>
    </websocket:handlers>

    <bean id="myHandler" class="org.springframework.samples.MyHandler"/>

</beans>
```

一个更高级的选项是扩展，`DefaultHandshakeHandler`它执行WebSocket握手的步骤，包括验证客户端起源，协商子协议以及其他详细信息。如果应用程序需要配置自定义项`RequestUpgradeStrategy`以适应尚不支持的WebSocket服务器引擎和版本，则它可能还需要使用此选项（有关此主题的更多信息，请参阅[部署](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#websocket-server-deployment)）。Java配置和XML名称空间都使自定义配置成为可能 `HandshakeHandler`。

 Spring提供了一个`WebSocketHandlerDecorator`基类，您可以使用它来装饰`WebSocketHandler`额外的行为。使用WebSocket Java配置或XML名称空间时，默认情况下会提供并添加日志记录和异常处理实现。在`ExceptionWebSocketHandlerDecorator`捕获了由任何出现的所有捕获的异常`WebSocketHandler`的方法，并关闭与状态WebSocket的会议`1011`，这表明服务器错误。

#### 4.2.3。部署方式

Spring WebSocket API易于集成到Spring MVC应用程序中，在该应用程序中`DispatcherServlet`可以同时服务HTTP WebSocket握手和其他HTTP请求。通过调用也很容易集成到其他HTTP处理方案中`WebSocketHttpRequestHandler`。这是方便且易于理解的。但是，对于JSR-356运行时，需要特别注意。

Java WebSocket API（JSR-356）提供了两种部署机制。第一个涉及启动时的Servlet容器类路径扫描（Servlet 3功能）。另一个是在Servlet容器初始化时使用的注册API。这两种机制都无法将单个“前端控制器”用于所有HTTP处理（包括WebSocket握手和所有其他HTTP请求），例如Spring MVC `DispatcherServlet`。

这是对JSR-356的一个重大限制，`RequestUpgradeStrategy`即使在JSR-356运行时中运行，Spring的WebSocket支持也可以通过服务器特定的实现来解决。Tomcat，Jetty，GlassFish，WebLogic，WebSphere和Undertow（和WildFly）目前存在此类策略。

已经创建了克服Java WebSocket API中的上述限制的请求，可以在[eclipse-ee4j / websocket-api＃211中](https://github.com/eclipse-ee4j/websocket-api/issues/211)进行跟踪 。Tomcat，Undertow和WebSphere提供了自己的API替代方案，使之可以做到这一点，而Jetty也可以实现。我们希望更多的服务器可以做到这一点。

另一个要考虑的因素是，期望支持JSR-356的Servlet容器执行`ServletContainerInitializer`（SCI）扫描，这可能会减慢应用程序的启动速度，在某些情况下会大大降低。如果在升级到支持JSR-356的Servlet容器版本后观察到重大影响，则应该可以通过使用中的`<absolute-ordering />`元素来选择性地启用或禁用Web片段（和SCI扫描）`web.xml`，如以下示例所示：

```xml
<web-app xmlns="http://java.sun.com/xml/ns/javaee"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://java.sun.com/xml/ns/javaee
        https://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"
    version="3.0">

    <absolute-ordering/>

</web-app>
```

然后，您可以按名称有选择地启用Web片段，例如Spring自己的片段， `SpringServletContainerInitializer`它提供对Servlet 3 Java初始化API的支持。以下示例显示了如何执行此操作：

```xml
<web-app xmlns="http://java.sun.com/xml/ns/javaee"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://java.sun.com/xml/ns/javaee
        https://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"
    version="3.0">

    <absolute-ordering>
        <name>spring_web</name>
    </absolute-ordering>

</web-app>
```

#### 4.2.4。服务器配置

[WebFlux](https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-websocket-server-config)

每个基础的WebSocket引擎都公开配置属性，这些属性控制运行时特征，例如消息缓冲区大小的大小，空闲超时等。

对于Tomcat，WildFly和GlassFish，可以将添加一个`ServletServerContainerFactoryBean`到WebSocket Java配置中，如以下示例所示：

~~~ java
@Configuration
@EnableWebSocket
public class WebSocketConfig implements WebSocketConfigurer {

    @Bean
    public ServletServerContainerFactoryBean createWebSocketContainer() {
        ServletServerContainerFactoryBean container = new ServletServerContainerFactoryBean();
        container.setMaxTextMessageBufferSize(8192);
        container.setMaxBinaryMessageBufferSize(8192);
        return container;
    }

}
~~~

以下示例显示了与先前示例等效的XML配置：

~~~ xml
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:websocket="http://www.springframework.org/schema/websocket"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/websocket
        https://www.springframework.org/schema/websocket/spring-websocket.xsd">

    <bean class="org.springframework...ServletServerContainerFactoryBean">
        <property name="maxTextMessageBufferSize" value="8192"/>
        <property name="maxBinaryMessageBufferSize" value="8192"/>
    </bean>

</beans>
~~~

 对于客户端WebSocket配置，应使用`WebSocketContainerFactoryBean` （XML）或`ContainerProvider.getWebSocketContainer()`（Java配置）。

~~~java
@Configuration
@EnableWebSocket
public class WebSocketConfig implements WebSocketConfigurer {

    @Override
    public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) {
        registry.addHandler(echoWebSocketHandler(),
            "/echo").setHandshakeHandler(handshakeHandler());
    }

    @Bean
    public DefaultHandshakeHandler handshakeHandler() {

        WebSocketPolicy policy = new WebSocketPolicy(WebSocketBehavior.SERVER);
        policy.setInputBufferSize(8192);
        policy.setIdleTimeout(600000);

        return new DefaultHandshakeHandler(
                new JettyRequestUpgradeStrategy(new WebSocketServerFactory(policy)));
    }

}
~~~

以下示例显示了与先前示例等效的XML配置：

~~~ xml
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:websocket="http://www.springframework.org/schema/websocket"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/websocket
        https://www.springframework.org/schema/websocket/spring-websocket.xsd">

    <websocket:handlers>
        <websocket:mapping path="/echo" handler="echoHandler"/>
        <websocket:handshake-handler ref="handshakeHandler"/>
    </websocket:handlers>

    <bean id="handshakeHandler" class="org.springframework...DefaultHandshakeHandler">
        <constructor-arg ref="upgradeStrategy"/>
    </bean>

    <bean id="upgradeStrategy" class="org.springframework...JettyRequestUpgradeStrategy">
        <constructor-arg ref="serverFactory"/>
    </bean>

    <bean id="serverFactory" class="org.eclipse.jetty...WebSocketServerFactory">
        <constructor-arg>
            <bean class="org.eclipse.jetty...WebSocketPolicy">
                <constructor-arg value="SERVER"/>
                <property name="inputBufferSize" value="8092"/>
                <property name="idleTimeout" value="600000"/>
            </bean>
        </constructor-arg>
    </bean>

</beans>
~~~

#### 4.2.5。允许的来源

[WebFlux](https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-websocket-server-cors)

从Spring Framework 4.1.5开始，WebSocket和SockJS的默认行为是仅接受同源请求。也可以允许所有或指定的来源列表。此检查主要用于浏览器客户端。没有任何措施可以阻止其他类型的客户端修改`Origin`标头值（有关更多详细信息，请参阅 [RFC 6454：Web Origin概念](https://tools.ietf.org/html/rfc6454)）。

三种可能的行为是：

- 仅允许同源请求（默认）：在此模式下，启用SockJS时，Iframe HTTP响应标头`X-Frame-Options`设置为`SAMEORIGIN`，并且JSONP传输被禁用，因为它不允许检查请求的来源。因此，启用此模式时，不支持IE6和IE7。
- 允许指定来源列表：每个允许的来源必须以`http://` 或开头`https://`。在此模式下，启用SockJS时，将禁用IFrame传输。因此，启用此模式时，不支持IE6至IE9。
- 允许所有来源：要启用此模式，应提供`*`作为允许的来源值。在这种模式下，所有传输都可用。

您可以配置WebSocket和SockJS允许的来源，如以下示例所示：

```java
import org.springframework.web.socket.config.annotation.EnableWebSocket;
import org.springframework.web.socket.config.annotation.WebSocketConfigurer;
import org.springframework.web.socket.config.annotation.WebSocketHandlerRegistry;

@Configuration
@EnableWebSocket
public class WebSocketConfig implements WebSocketConfigurer {

    @Override
    public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) {
        registry.addHandler(myHandler(), "/myHandler").setAllowedOrigins("https://mydomain.com");
    }

    @Bean
    public WebSocketHandler myHandler() {
        return new MyHandler();
    }

}
```

### 4.3。SockJS后备

在公共Internet上，控件外部的限制性代理可能会阻止WebSocket交互，这可能是因为未将它们配置为传递`Upgrade`标头，或者是因为它们关闭了长期处于空闲状态的连接。

解决此问题的方法是WebSocket仿真，即先尝试使用WebSocket，然后再尝试使用基于HTTP的技术来模拟WebSocket交互并公开相同的应用程序级API。

在Servlet堆栈上，Spring框架为SockJS协议提供服务器（以及客户端）支持。

#### 4.3.1。总览

SockJS的目标是让应用程序使用WebSocket API，但在运行时需要时使用非WebSocket替代方法，而无需更改应用程序代码。

SockJS包括：

- 所述[SockJS协议](https://github.com/sockjs/sockjs-protocol) 以可执行的形式定义的 [解说的测试](https://sockjs.github.io/sockjs-protocol/sockjs-protocol-0.3.3.html)。
- 该[SockJS JavaScript客户端](https://github.com/sockjs/sockjs-client/) -在浏览器中使用客户端库。
- SockJS服务器实现，包括Spring Framework`spring-websocket`模块中的一个。
- `spring-websocket`模块中的SockJS Java客户端（从4.1版开始）。

SockJS设计用于浏览器。它使用多种技术来支持各种浏览器版本。有关SockJS传输类型和浏览器的完整列表，请参见 [SockJS客户端](https://github.com/sockjs/sockjs-client/)页面。传输分为三大类：WebSocket，HTTP流和HTTP长轮询。有关这些类别的概述，请参阅 [此博客文章](https://spring.io/blog/2012/05/08/spring-mvc-3-2-preview-techniques-for-real-time-updates/)。

SockJS客户端从发送开始以`GET /info`从服务器获取基本信息。在那之后，它必须决定使用哪种交通工具。如果可能，请使用WebSocket。如果没有，在大多数浏览器中，至少有一个HTTP流选项。如果不是，则使用HTTP（长）轮询。

所有传输请求都具有以下URL结构：

```
https://host:port/myApp/myEndpoint/{server-id}/{session-id}/{transport}
```

这里：

- `{server-id}` 在路由集群中的请求时很有用，否则不使用。
- `{session-id}` 关联属于SockJS会话的HTTP请求。
- `{transport}`指示传输类型（例如，`websocket`，`xhr-streaming`，和其它物质）。

WebSocket传输仅需要单个HTTP请求即可进行WebSocket握手。此后所有消息在该套接字上交换。

HTTP传输需要更多请求。例如，Ajax / XHR流依赖于对服务器到客户端消息的一个长时间运行的请求，以及对客户端到服务器消息的其他HTTP POST请求。长轮询类似，不同之处在于长轮询在每次服务器到客户端发送后结束当前请求。

SockJS添加了最少的消息框架。例如，服务器`o` 最初发送字母（“打开”框架），消息以`a["message1","message2"]` （JSON编码的数组）发送，`h`如果在25秒内没有消息流（默认情况下），则以字母（“心跳”框架）发送消息，以及字母`c`（“关闭”框架）以关闭会话。

要了解更多信息，请在浏览器中运行示例并查看HTTP请求。SockJS客户端允许修复传输列表，因此可以一次查看每个传输。SockJS客户端还提供了调试标志，该标志可在浏览器控制台中启用有用的消息。在服务器端，您可以启用的 `TRACE`日志记录`org.springframework.web.socket`。有关更多详细信息，请参见SockJS协议 [旁白测试](https://sockjs.github.io/sockjs-protocol/sockjs-protocol-0.3.3.html)。

#### 4.3.2。启用SockJS

您可以通过Java配置启用SockJS，如以下示例所示：

~~~ java
@Configuration
@EnableWebSocket
public class WebSocketConfig implements WebSocketConfigurer {

    @Override
    public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) {
        registry.addHandler(myHandler(), "/myHandler").withSockJS();
    }

    @Bean
    public WebSocketHandler myHandler() {
        return new MyHandler();
    }

}
~~~

以下示例显示了与先前示例等效的XML配置：

~~~ xml
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:websocket="http://www.springframework.org/schema/websocket"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/websocket
        https://www.springframework.org/schema/websocket/spring-websocket.xsd">

    <websocket:handlers>
        <websocket:mapping path="/myHandler" handler="myHandler"/>
        <websocket:sockjs/>
    </websocket:handlers>

    <bean id="myHandler" class="org.springframework.samples.MyHandler"/>

</beans>
~~~

前面的示例用于Spring MVC应用程序，并且应包含在[`DispatcherServlet`](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-servlet)的配置中。但是，Spring的WebSocket和SockJS支持不依赖于Spring MVC。在[`SockJsHttpRequestHandler`](https://docs.spring.io/spring-framework/docs/5.3.1/javadoc-api/org/springframework/web/socket/sockjs/support/SockJsHttpRequestHandler.html)的帮助下，将其集成到其他HTTP服务环境中相对简单 。

在浏览器端，应用程序可以使用 [`sockjs-client`](https://github.com/sockjs/sockjs-client/)（版本1.0.x）。它模拟W3C WebSocket API，并与服务器通信以选择最佳的传输选项，具体取决于运行它的浏览器。请参阅 [sockjs-client](https://github.com/sockjs/sockjs-client/)页面和浏览器支持的传输类型列表。客户端还提供了几个配置选项-例如，指定要包括的传输。

#### 4.3.3。IE 8和9

Internet Explorer 8和9仍在使用。它们是拥有SockJS的关键原因。本节涵盖有关在这些浏览器中运行的重要注意事项。

SockJS客户端通过使用Microsoft的，在IE 8和9中支持Ajax / XHR流 [`XDomainRequest`](https://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx)。跨域有效，但不支持发送Cookie。Cookies对于Java应用程序通常是必不可少的。但是，由于SockJS客户端可用于多种服务器类型（而不仅仅是Java类型），因此它需要知道cookie是否重要。如果是这样，则SockJS客户端更喜欢Ajax / XHR进行流传输。否则，它依赖于基于iframe的技术。

首先`/info`从SockJS客户端请求是针对可能影响客户的传输选择信息的请求。这些详细信息之一是服务器应用程序是否依赖Cookie（例如，出于身份验证目的或使用粘性会话进行群集）。Spring的SockJS支持包括名为的属性`sessionCookieNeeded`。由于大多数Java应用程序都依赖`JSESSIONID` cookie ，因此默认情况下启用此功能。如果您的应用程序不需要它，则可以关闭此选项，然后SockJS客户端应`xdr-streaming`在IE 8和9中进行选择。

如果你使用基于iframe的传输，记住，浏览器可以通过指示HTTP响应头设置为阻止特定网页上的使用iframe`X-Frame-Options`来`DENY`， `SAMEORIGIN`或`ALLOW-FROM <origin>`。这用于防止 [点击劫持](https://www.owasp.org/index.php/Clickjacking)。

#### 4.3.4。心跳

SockJS协议要求服务器发送心跳消息，以防止代理断定连接已挂起。Spring SockJS配置具有一个名为的属性`heartbeatTime`，您可以使用该属性来自定义频率。默认情况下，假设没有其他消息在该连接上发送，则心跳将在25秒后发送。这个25秒的值符合以下 [IETF](https://tools.ietf.org/html/rfc6202)对公共Internet应用程序的[建议](https://tools.ietf.org/html/rfc6202)。

 通过WebSocket和SockJS使用STOMP时，如果STOMP客户端和服务器协商要交换的心跳，则会禁用SockJS心跳。

Spring SockJS支持还允许您配置`TaskScheduler`来安排心跳任务。任务调度程序由线程池支持，其默认设置基于可用处理器的数量。您应该考虑根据您的特定需求自定义设置。

#### 4.3.5。客户端断开连接

HTTP流和HTTP长轮询SockJS传输要求连接保持打开的时间比平常更长。有关这些技术的概述，请参见此 [博客文章](https://spring.io/blog/2012/05/08/spring-mvc-3-2-preview-techniques-for-real-time-updates/)。

在Servlet容器中，这是通过Servlet 3异步支持完成的，该支持允许退出Servlet容器线程，处理请求并继续写入另一个线程的响应。

一个特定的问题是，Servlet API不会为已离开的客户端提供通知。请参阅[eclipse-ee4j / servlet-api＃44](https://github.com/eclipse-ee4j/servlet-api/issues/44)。但是，Servlet容器在随后尝试写入响应时会引发异常。由于Spring的SockJS服务支持服务器发送的心跳信号（默认情况下每25秒发送一次），这意味着通常会在该时间段内（或更早，如果消息发送频率更高）检测到客户端断开连接。

 结果，由于客户端已断开连接，可能会发生网络I / O故障，这可能会在日志中填充不必要的堆栈跟踪。Spring会尽最大努力找出代表客户端断开连接（特定于每个服务器）的此类网络故障，并使用专用的日志类别`DISCONNECTED_CLIENT_LOG_CATEGORY` （在中定义`AbstractSockJsSession`）来记录最少的消息。如果需要查看堆栈跟踪，可以将该日志类别设置为TRACE。

#### 4.3.6。SockJS和CORS

如果您允许跨域请求（请参见[Allowed Origins](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#websocket-server-allowed-origins)），则SockJS协议将CORS用于XHR流和轮询传输中的跨域支持。因此，除非在响应中检测到CORS标头的存在，否则将自动添加CORS标头。因此，如果已经将应用程序配置为提供CORS支持（例如，通过Servlet过滤器），则Spring会`SockJsService`跳过这一部分。

也可以通过`suppressCors`在Spring的SockJsService中设置属性来禁用这些CORS标头 的添加。

SockJS需要以下标头和值：

- `Access-Control-Allow-Origin`：从`Origin`请求标头的值初始化。
- `Access-Control-Allow-Credentials`：始终设置为`true`。
- `Access-Control-Request-Headers`：从等效请求标头中的值初始化。
- `Access-Control-Allow-Methods`：传输支持的HTTP方法（请参阅`TransportType`枚举）。
- `Access-Control-Max-Age`：设置为31536000（1年）。

有关确切的实现，请参阅`addCorsHeaders`中的`AbstractSockJsService`和`TransportType`源代码中的枚举。

另外，如果CORS配置允许，请考虑排除带有SockJS端点前缀的URL，从而让Spring来`SockJsService`处理它。

#### 4.3.7。 `SockJsClient`

Spring提供了一个SockJS Java客户端，无需使用浏览器即可连接到远程SockJS端点。当需要通过公用网络在两个服务器之间进行双向通信时（即，网络代理可能会阻止使用WebSocket协议），这特别有用。SockJS Java客户端对于测试目的（例如，模拟大量并发用户）也非常有用。

该SockJS Java客户端支持`websocket`，`xhr-streaming`以及`xhr-polling` 运输。其余的仅在浏览器中有意义。

您可以使用配置`WebSocketTransport`：

- `StandardWebSocketClient` 在JSR-356运行时中。
- `JettyWebSocketClient` 通过使用Jetty 9+本机WebSocket API。
- Spring的任何实现`WebSocketClient`。

`XhrTransport`从定义的角度来看，An同时支持`xhr-streaming`和`xhr-polling`，因为从客户端的角度来看，除了用于连接服务器的URL之外没有其他区别。当前有两种实现：

- `RestTemplateXhrTransport`使用Spring的`RestTemplate`HTTP请求。
- `JettyXhrTransport``HttpClient`对HTTP请求使用Jetty 。

以下示例显示了如何创建SockJS客户端并连接到SockJS端点：

~~~java
List<Transport> transports = new ArrayList<>(2);
transports.add(new WebSocketTransport(new StandardWebSocketClient()));
transports.add(new RestTemplateXhrTransport());

SockJsClient sockJsClient = new SockJsClient(transports);
sockJsClient.doHandshake(new MyWebSocketHandler(), "ws://example.com:8080/sockjs");
~~~

SockJS对消息使用JSON格式的数组。默认情况下，使用Jackson 2，并且需要在类路径上。或者，您可以配置的自定义实现 `SockJsMessageCodec`并在上进行配置`SockJsClient`。

为了`SockJsClient`模拟大量并发用户，您需要配置基础HTTP客户端（用于XHR传输）以允许足够数量的连接和线程。以下示例显示了如何使用Jetty进行操作：

~~~java
HttpClient jettyHttpClient = new HttpClient();
jettyHttpClient.setMaxConnectionsPerDestination(1000);
jettyHttpClient.setExecutor(new QueuedThreadPool(1000));
~~~

下面的示例显示了与服务器端SockJS相关的属性（有关详细信息，请参见javadoc），您还应该考虑自定义：

~~~java
@Configuration
public class WebSocketConfig extends WebSocketMessageBrokerConfigurationSupport {

    @Override
    public void registerStompEndpoints(StompEndpointRegistry registry) {
        registry.addEndpoint("/sockjs").withSockJS()
            .setStreamBytesLimit(512 * 1024) 
            .setHttpMessageCacheSize(1000) 
            .setDisconnectDelay(30 * 1000); 
    }

    // ...
}
~~~

1. 将该`streamBytesLimit`属性设置为512KB（默认值为128KB —  `128 * 1024`）。
2. 将`httpMessageCacheSize`属性设置为1,000（默认值为`100`）。
3.  将`disconnectDelay`属性设置为30属性秒（默认为5秒—  `5 * 1000`）。

### 4.4. STOMP

WebSocket协议定义了两种消息类型（文本消息和二进制消息），但是其内容未定义。该协议定义了一种机制，客户端和服务器可以协商子协议（即高级消息协议），以在WebSocket上使用该协议来定义每种协议可以发送的消息类型，格式，内容。每个消息，依此类推。子协议的使用是可选的，但是无论哪种方式，客户端和服务器都需要就定义消息内容的某种协议达成共识。

#### 4.4.1。总览

[STOMP](https://stomp.github.io/stomp-specification-1.2.html#Abstract)（面向简单文本的消息协议）最初是为脚本语言（例如Ruby，Python和Perl）创建的，以连接到企业消息代理。它旨在解决常用消息传递模式的最小子集。STOMP可以在任何可靠的双向流网络协议上使用，例如TCP和WebSocket。尽管STOMP是面向文本的协议，但是消息有效负载可以是文本或二进制。

STOMP是基于帧的协议，其帧以HTTP为模型。以下清单显示了STOMP帧的结构：

STOMP是基于帧的协议，其帧以HTTP为模型。以下清单显示了STOMP帧的结构：

```
COMMAND
header1:value1
header2:value2

Body^@
```

客户端可以使用`SEND`或`SUBSCRIBE`命令来发送或订阅消息，以及`destination`描述消息内容以及应由谁接收的标头。这启用了一种简单的发布-订阅机制，您可以使用该机制通过代理将消息发送到其他连接的客户端，或者将消息发送到服务器以请求执行某些工作。

当您使用Spring的STOMP支持时，Spring WebSocket应用程序将充当客户端的STOMP代理。消息被路由到`@Controller`消息处理方法或简单的内存中代理，该代理跟踪订阅并向订阅的用户广播消息。您还可以将Spring配置为与专用的STOMP代理（例如RabbitMQ，ActiveMQ和其他代理）一起使用，以实际广播消息。在那种情况下，Spring维护与代理的TCP连接，将消息中继给它，并将消息从它传递到连接的WebSocket客户端。因此，Spring Web应用程序可以依靠基于HTTP的统一安全性，通用验证以及用于消息处理的熟悉的编程模型。

以下示例显示了一个订阅以接收股票报价的客户端，服务器可能会定期发出该股票报价（例如，通过计划任务，该任务通过将消息发送给`SimpMessagingTemplate`代理）：

```
SUBSCRIBE
id:sub-1
destination:/topic/price.stock.*

^@
```

以下示例显示了一个客户端发送的交易请求，服务器可以通过一种`@MessageMapping`方法来处理该交易请求：

```
SEND
destination:/queue/trade
content-type:application/json
content-length:44

{"action":"BUY","ticker":"MMM","shares",44}^@
```

执行后，服务器可以向客户广播交易确认消息和详细信息。

在STOMP规范中，目的地的含义是故意不透明的。它可以是任何字符串，并且完全由STOMP服务器来定义它们支持的目的地的语义和语法。但是，目的地通常是类似路径的字符串，其中`/topic/..`包含发布-订阅（一对多）和`/queue/`暗示点对点（一对一）消息交换。

STOMP服务器可以使用该`MESSAGE`命令向所有订户广播消息。以下示例显示了服务器向订阅的客户端发送股票报价的服务器：

```
MESSAGE
message-id:nxahklf6-1
subscription:sub-1
destination:/topic/price.stock.MMM

{"ticker":"MMM","price":129.45}^@
```

服务器无法发送未经请求的消息。来自服务器的所有消息都必须响应特定的客户端订阅，并且 `subscription-id`服务器消息的`id`标头必须与客户端订阅的标头匹配。

前面的概述旨在提供对STOMP协议的最基本的了解。我们建议您全面阅读协议 [规范](https://stomp.github.io/stomp-specification-1.2.html)。

#### 4.4.2。好处

与使用原始WebSocket相比，使用STOMP作为子协议可以使Spring Framework和Spring Security提供更丰富的编程模型。关于HTTP与原始TCP以及它如何使Spring MVC和其他Web框架提供丰富的功能，可以得出相同的观点。以下是好处列表：

- 无需发明自定义消息协议和消息格式。
- 可以使用STOMP客户端，包括 Spring框架中的[Java客户端](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#websocket-stomp-client)。
- 您可以（可选）使用消息代理（例如RabbitMQ，ActiveMQ和其他代理）来管理订阅和广播消息。
- 可以在任意数量的`@Controller`实例中组织应用程序逻辑，并且可以基于STOMP目标标头将消息路由到它们，而`WebSocketHandler`对于给定的连接，可以使用单个消息处理原始WebSocket消息。
- 您可以使用Spring Security基于STOMP目的地和消息类型来保护消息。

#### 4.4.3。启用STOMP

`	spring-messaging`和 `spring-websocket`模块中提供了STOMP over WebSocket支持。一旦有了这些依赖关系，就可以使用[SockJS 	Fallback](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#websocket-fallback)通过WebSocket公开STOMP端点，如以下示例所示：

```java
import org.springframework.web.socket.config.annotation.EnableWebSocketMessageBroker;
import org.springframework.web.socket.config.annotation.StompEndpointRegistry;

@Configuration
@EnableWebSocketMessageBroker
public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {

    @Override
    public void registerStompEndpoints(StompEndpointRegistry registry) {
        registry.addEndpoint("/portfolio").withSockJS();  
    }

    @Override
    public void configureMessageBroker(MessageBrokerRegistry config) {
        config.setApplicationDestinationPrefixes("/app"); 
        config.enableSimpleBroker("/topic", "/queue"); 
    }
}
```

1. `/portfolio` 是WebSocket（或SockJS）客户端需要连接到WebSocket握手的终结点的HTTP URL。
2. 目的标头以STOMP开头的STOMP消息`/app`将路由到 类中的`@MessageMapping`方法`@Controller`。
3. 使用内置的消息代理进行订阅和广播，并将目标标头以其开头的消息路由`/topic `or `/queue`到代理。

以下示例显示了与先前示例等效的XML配置：

```xml
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:websocket="http://www.springframework.org/schema/websocket"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/websocket
        https://www.springframework.org/schema/websocket/spring-websocket.xsd">

    <websocket:message-broker application-destination-prefix="/app">
        <websocket:stomp-endpoint path="/portfolio">
            <websocket:sockjs/>
        </websocket:stomp-endpoint>
        <websocket:simple-broker prefix="/topic, /queue"/>
    </websocket:message-broker>

</beans>
```

对于内置的简单代理，`/topic`and`/queue`前缀没有任何特殊含义。它们仅是区分发布订阅消息传递和点对点消息传递的约定（即，许多订户与一个消费者）。使用外部代理时，请检查代理的STOMP页面以了解其支持哪种STOMP目标和前缀。

要从浏览器进行连接，对于SockJS，您可以使用 [`sockjs-client`](https://github.com/sockjs/sockjs-client)。对于STOMP，许多应用程序都使用了[jmesnil / stomp-websocket](https://github.com/jmesnil/stomp-websocket)库（也称为stomp.js），该库功能齐全，已在生产中使用多年，但不再维护。目前， [JSteunou / webstomp-client](https://github.com/JSteunou/webstomp-client)是该库中最活跃且发展最快的后继程序。以下示例代码基于此：

```javascript
var socket = new SockJS("/spring-websocket-portfolio/portfolio");
var stompClient = webstomp.over(socket);

stompClient.connect({}, function(frame) {
}
```

另外，如果您通过WebSocket（没有SockJS）进行连接，则可以使用以下代码：

```javascript
var socket = new WebSocket("/spring-websocket-portfolio/portfolio");
var stompClient = Stomp.over(socket);

stompClient.connect({}, function(frame) {
}
```

注意，`stompClient`在前面的示例中不需要指定`login` 和`passcode`标头。即使这样做，它们也会在服务器端被忽略（或更确切地说，被覆盖）。有关[身份验证](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#websocket-stomp-authentication)的更多信息，请参见[连接到代理](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#websocket-stomp-handle-broker-relay-configure) 和[身份](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#websocket-stomp-authentication)验证。

有关更多示例代码，请参见：

- [使用WebSocket构建交互式Web应用程序](https://spring.io/guides/gs/messaging-stomp-websocket/) -入门指南。
- [股票投资组合](https://github.com/rstoyanchev/spring-websocket-portfolio) —一个示例应用程序。

#### 4.4.4。WebSocket服务器

要配置基础WebSocket服务器，请应用“[服务器配置”中](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#websocket-server-runtime-configuration)的信息 。对于码头，但你需要设置`HandshakeHandler`并`WebSocketPolicy`通过`StompEndpointRegistry`：

```java
@Configuration
@EnableWebSocketMessageBroker
public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {

    @Override
    public void registerStompEndpoints(StompEndpointRegistry registry) {
        registry.addEndpoint("/portfolio").setHandshakeHandler(handshakeHandler());
    }

    @Bean
    public DefaultHandshakeHandler handshakeHandler() {

        WebSocketPolicy policy = new WebSocketPolicy(WebSocketBehavior.SERVER);
        policy.setInputBufferSize(8192);
        policy.setIdleTimeout(600000);

        return new DefaultHandshakeHandler(
                new JettyRequestUpgradeStrategy(new WebSocketServerFactory(policy)));
    }
}
```

#### 4.4.5。消息流

公开STOMP端点后，Spring应用程序将成为已连接客户端的STOMP代理。本节描述服务器端的消息流。

该`spring-messaging`模块包含对消息传递应用程序的基础支持，该消息传递应用程序起源于[Spring Integration](https://spring.io/spring-integration)，后来被提取并合并到Spring Framework中，以便在许多[Spring项目](https://spring.io/projects)和应用程序场景中更广泛地使用 。下面的列表简要描述了一些可用的消息传递抽象：

- [消息](https://docs.spring.io/spring-framework/docs/5.3.1/javadoc-api/org/springframework/messaging/Message.html)：[消息的](https://docs.spring.io/spring-framework/docs/5.3.1/javadoc-api/org/springframework/messaging/Message.html)简单表示形式，包括标题和有效负载。
- [MessageHandler](https://docs.spring.io/spring-framework/docs/5.3.1/javadoc-api/org/springframework/messaging/MessageHandler.html)：处理消息的合同。
- [MessageChannel](https://docs.spring.io/spring-framework/docs/5.3.1/javadoc-api/org/springframework/messaging/MessageChannel.html)：用于发送使生产者和消费者之间松散耦合的消息的合同。
- [SubscribableChannel](https://docs.spring.io/spring-framework/docs/5.3.1/javadoc-api/org/springframework/messaging/SubscribableChannel.html)： `MessageChannel`具有`MessageHandler`订阅者。
- [ExecutorSubscribableChannel](https://docs.spring.io/spring-framework/docs/5.3.1/javadoc-api/org/springframework/messaging/support/ExecutorSubscribableChannel.html)： `SubscribableChannel`使用一个`Executor`邮件传递。

Java配置（即`@EnableWebSocketMessageBroker`）和XML名称空间配置（即`<websocket:message-broker>`）都使用前面的组件来组装消息工作流。下图显示了启用简单内置消息代理时使用的组件：

![消息流简单代理](https://docs.spring.io/spring-framework/docs/current/reference/html/images/message-flow-simple-broker.png)

上图显示了三个消息通道：

- `clientInboundChannel`：用于传递从WebSocket客户端收到的消息。
- `clientOutboundChannel`：用于向WebSocket客户端发送服务器消息。
- `brokerChannel`：用于从服务器端应用程序代码内将消息发送到消息代理。

下图显示了将外部代理（例如RabbitMQ）配置为用于管理订阅和广播消息时使用的组件：

![消息流代理中继](https://docs.spring.io/spring-framework/docs/current/reference/html/images/message-flow-broker-relay.png)

前面两个图之间的主要区别是使用“代理中继”将消息通过TCP传递到外部STOMP代理，以及将消息从代理传递到订阅的客户端。

从WebSocket连接接收到消息后，消息将被解码为STOMP帧，转换为Spring`Message`表示，然后发送给 `clientInboundChannel`进行进一步处理。例如，目标标头以开头的STOMP消息`/app`可以路由到带`@MessageMapping`注释的控制器中的方法，而`/topic`和`/queue`消息可以直接路由到消息代理。

`@Controller`处理来自客户端的STOMP消息的注释可以通过将消息发送到消息代理`brokerChannel`，并且代理通过将该消息广播给匹配的订户`clientOutboundChannel`。相同的控制器还可以响应HTTP请求执行相同的操作，因此客户端可以执行HTTP POST，然后一种`@PostMapping`方法可以将消息发送到消息代理，以广播到订阅的客户端。

我们可以通过一个简单的示例跟踪流程。考虑以下示例，该示例设置了服务器：

```java
@Configuration
@EnableWebSocketMessageBroker
public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {

    @Override
    public void registerStompEndpoints(StompEndpointRegistry registry) {
        registry.addEndpoint("/portfolio");
    }

    @Override
    public void configureMessageBroker(MessageBrokerRegistry registry) {
        registry.setApplicationDestinationPrefixes("/app");
        registry.enableSimpleBroker("/topic");
    }
}

@Controller
public class GreetingController {

    @MessageMapping("/greeting") {
    public String handle(String greeting) {
        return "[" + getTimestamp() + ": " + greeting;
    }
}
```

前面的示例支持以下流程：

1. 客户端连接到`http://localhost:8080/portfolio`WebSocket连接，并且一旦建立了WebSocket连接，STOMP帧就开始在其上流动。
2. 客户端发送SUBSCRIBE帧，目标标头为`/topic/greeting`。收到并解码后，该消息将发送到`clientInboundChannel`，然后路由到消息代理，该代理存储客户端订阅。
3. 客户端向发送一个aSEND帧`/app/greeting`。该`/app`前缀有助于它的路线注解控制器。`/app`除去前缀后，目标的其余`/greeting` 部分将映射到中的`@MessageMapping`方法`GreetingController`。
4. 从返回的值`GreetingController`转换为`Message`带有有效负载的Spring ，该有效负载基于返回值和默认目标标头 `/topic/greeting`（从输入目标派生，用`/app`替换 `/topic`）。结果消息将发送到`brokerChannel`并由消息代理处理。
5. 消息代理找到所有匹配的订户，并通过通过`clientOutboundChannel`，向每个发送一个MESSAGE帧，消息从中被编码为STOMP帧并通过WebSocket连接发送。

下一节将提供有关带注释的方法的更多详细信息，包括支持的参数类型和返回值。

#### 4.4.6。带注释的控制器

应用程序可以使用带注释的`@Controller`类来处理来自客户端的消息。此类可以声明`@MessageMapping`，`@SubscribeMapping`和`@ExceptionHandler` 方法，如以下主题所述：

- [`@MessageMapping`](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#websocket-stomp-message-mapping)
- [`@SubscribeMapping`](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#websocket-stomp-subscribe-mapping)
- [`@MessageExceptionHandler`](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#websocket-stomp-exception-handler)

##### `@MessageMapping`

您可以`@MessageMapping`用来注释根据消息的目的地路由消息的方法。在方法级别和类型级别都支持它。在类型级别，`@MessageMapping`用于表示控制器中所有方法之间的共享映射。

默认情况下，映射值是Ant样式的路径模式（例如`/thing*`，`/thing/**`），包括对模板变量（例如，`/thing/{id}`）的支持。可以通过`@DestinationVariable`方法参数引用这些值。应用程序还可以切换到以点分隔的映射的目标约定，如“ [作为分隔符的点”中所述](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#websocket-stomp-destination-separator)。

###### 支持的方法参数

下表描述了方法参数：

| 方法参数                                                     | 描述                                                         |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| `Message`                                                    | 用于访问完整的消息。                                         |
| `MessageHeaders`                                             | 用于访问中的标头`Message`。                                  |
| `MessageHeaderAccessor`，`SimpMessageHeaderAccessor`和`StompHeaderAccessor` | 用于通过类型化访问器方法访问标头。                           |
| `@Payload`                                                   | 为了访问消息的有效负载，由configure转换（例如，从JSON转换） `MessageConverter`。不需要此注释，因为默认情况下会假定没有其他自变量匹配。您可以使用`@javax.validation.Valid`或Spring的注释有效负载参数`@Validated`，以使有效负载参数得到自动验证。 |
| `@Header`                                                    | 用于访问特定的标头值-`org.springframework.core.convert.converter.Converter`如有必要，还可以使用进行类型转换 。 |
| `@Headers`                                                   | 用于访问消息中的所有标题。此参数必须可分配给 `java.util.Map`。 |
| `@DestinationVariable`                                       | 用于访问从消息目标中提取的模板变量。根据需要将值转换为声明的方法参数类型。 |
| `java.security.Principal`                                    | 反映在WebSocket HTTP握手时登录的用户。                       |

###### 返回值

默认情况下，方法的返回值`@MessageMapping`通过匹配被序列化为有效负载，`MessageConverter`并以形式发送`Message`给`brokerChannel`，从中将其广播给订户。出站邮件的目的地与入站邮件的目的地相同，但前缀为`/topic`。

您可以使用`@SendTo`和`@SendToUser`注释来自定义输出消息的目的地。`@SendTo`用于自定义目标目的地或指定多个目的地。`@SendToUser`用于将输出消息仅定向到与输入消息关联的用户。请参阅[用户目的地](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#websocket-stomp-user-destination)。

您可以同时使用`@SendTo`，并`@SendToUser`在同一时间在同一个方法，无一不是在一流水平，在这种情况下，他们充当类中的方法默认支持。但是，请记住，任何方法级别`@SendTo`或`@SendToUser`注释都将在类级别覆盖所有此类注释。

消息可以异步处理和`@MessageMapping`方法可以返回 `ListenableFuture`，`CompletableFuture`或`CompletionStage`。

请注意，`@SendTo`并`@SendToUser`仅仅是相当于使用便利 `SimpMessagingTemplate`发送消息。如有必要，对于更高级的方案， `@MessageMapping`可以`SimpMessagingTemplate`直接使用直接方法。这可以代替返回值，也可以附加于返回值。请参阅[发送消息](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#websocket-stomp-handle-send)。

##### `@SubscribeMapping`

`@SubscribeMapping`与相似，`@MessageMapping`但将映射范围缩小到仅订阅消息。它支持相同的 [方法参数](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#websocket-stomp-message-mapping)的`@MessageMapping`。但是，对于返回值，默认情况下，消息直接发送给客户端（通过 `clientOutboundChannel`，以响应订阅），而不发送给代理（通过 `brokerChannel`，作为对匹配订阅的广播）。添加`@SendTo`或 `@SendToUser`覆盖此行为，然后发送给代理。

什么时候有用？假定代理映射到`/topic`和`/queue`，而应用程序控制器映射到`/app`。在此设置中，代理将存储所有订阅，`/topic`并`/queue`打算将其用于重复广播，并且不需要应用程序参与。客户端也可以预订某个`/app`目的地，并且控制器可以响应该预订而返回一个值，而无需经纪人参与，而无需再次存储或使用该预订（实际上是一次请求-答复交换）。一个用例是在启动时用初始数据填充UI。

什么时候没有用？不要尝试将代理和控制器映射到相同的目标前缀，除非出于某种原因您希望两者都独立处理消息（包括订阅）。入站消息是并行处理的。无法保证经纪人还是控制者先处理给定消息。如果要在存储预订并准备好广播时通知目标，则客户端应请求服务器是否支持收据（简单代理不支持）。例如，对于Java [STOMP客户端](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#websocket-stomp-client)，您可以执行以下操作添加收据：

```java
@Autowired
private TaskScheduler messageBrokerTaskScheduler;

// During initialization..
stompClient.setTaskScheduler(this.messageBrokerTaskScheduler);

// When subscribing..
StompHeaders headers = new StompHeaders();
headers.setDestination("/topic/...");
headers.setReceipt("r1");
FrameHandler handler = ...;
stompSession.subscribe(headers, handler).addReceiptTask(() -> {
    // Subscription ready...
});
```

服务器侧选择是[注册](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#websocket-stomp-interceptors)一个 `ExecutorChannelInterceptor`上`brokerChannel`并实施`afterMessageHandled` 被消息之后被调用，包括订阅，已处理方法。

##### `@MessageExceptionHandler`

应用程序可以使用`@MessageExceptionHandler`方法来处理方法中的异常 `@MessageMapping`。如果要访问异常实例，则可以在批注本身中声明异常，也可以通过方法参数声明异常。以下示例通过方法参数声明异常：

```java
@Controller
public class MyController {

    // ...

    @MessageExceptionHandler
    public ApplicationError handleException(MyException exception) {
        // ...
        return appError;
    }
}
```

`@MessageExceptionHandler`方法支持灵活的方法签名，并支持与方法相同的方法参数类型和返回值 [`@MessageMapping`](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#websocket-stomp-message-mapping)。

通常，`@MessageExceptionHandler`方法适用于`@Controller`声明它们的类（或类层次结构）。如果您希望此类方法在全局范围内（跨控制器）应用，则可以在标有的类中声明它们 `@ControllerAdvice`。这与Spring MVC中可用的[类似支持](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-controller-advice)相当 。

#### 4.4.7。传送讯息

如果要从应用程序的任何部分向连接的客户端发送消息怎么办？任何应用程序组件都可以将消息发送到`brokerChannel`。最简单的方法是注入a`SimpMessagingTemplate`并使用它发送消息。通常，您将按类型注入它，如以下示例所示：

```java
@Controller
public class GreetingController {

    private SimpMessagingTemplate template;

    @Autowired
    public GreetingController(SimpMessagingTemplate template) {
        this.template = template;
    }

    @RequestMapping(path="/greetings", method=POST)
    public void greet(String greeting) {
        String text = "[" + getTimestamp() + "]:" + greeting;
        this.template.convertAndSend("/topic/greetings", text);
    }

}
```

但是，`brokerMessagingTemplate`如果存在另一个相同类型的bean，也可以通过其名称（）对其进行限定。

#### 4.4.8。简单代理

内置的简单消息代理处理来自客户端的订阅请求，将其存储在内存中，并将消息广播到具有匹配目标的已连接客户端。该代理支持类似路径的目标，包括对Ant样式目标模式的订阅。

应用程序还可以使用点分隔（而不是斜杠分隔）目标。参见[点作为分隔符](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#websocket-stomp-destination-separator)。

如果配置了任务调度程序，则简单代理支持 [STOMP心跳](https://stomp.github.io/stomp-specification-1.2.html#Heart-beating)。为此，您可以声明自己的调度程序，也可以使用内部自动声明和使用的调度程序。以下示例显示如何声明自己的调度程序：

```java
@Configuration
@EnableWebSocketMessageBroker
public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {

    private TaskScheduler messageBrokerTaskScheduler;

    @Autowired
    public void setMessageBrokerTaskScheduler(TaskScheduler taskScheduler) {
        this.messageBrokerTaskScheduler = taskScheduler;
    }

    @Override
    public void configureMessageBroker(MessageBrokerRegistry registry) {

        registry.enableSimpleBroker("/queue/", "/topic/")
                .setHeartbeatValue(new long[] {10000, 20000})
                .setTaskScheduler(this.messageBrokerTaskScheduler);

        // ...
    }
}
```

#### 4.4.9。外部代理

简单代理非常适合入门，但仅支持STOMP命令的子集（它不支持ack，回执和其他一些功能），依赖于简单的消息发送循环，并且不适合于集群。或者，您可以升级应用程序以使用功能齐全的消息代理。

请参阅STOMP文档以了解您选择的消息代理（例如 [RabbitMQ](https://www.rabbitmq.com/stomp.html)， [ActiveMQ](https://activemq.apache.org/stomp.html)等），安装代理，并在启用STOMP支持的情况下运行它。然后，您可以在Spring配置中启用STOMP代理中继（而不是简单代理）。

以下示例配置启用了功能齐全的代理：

```java
@Configuration
@EnableWebSocketMessageBroker
public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {

    @Override
    public void registerStompEndpoints(StompEndpointRegistry registry) {
        registry.addEndpoint("/portfolio").withSockJS();
    }

    @Override
    public void configureMessageBroker(MessageBrokerRegistry registry) {
        registry.enableStompBrokerRelay("/topic", "/queue");
        registry.setApplicationDestinationPrefixes("/app");
    }

}
```

以下示例显示了与先前示例等效的XML配置：

```xml
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:websocket="http://www.springframework.org/schema/websocket"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/websocket
        https://www.springframework.org/schema/websocket/spring-websocket.xsd">

    <websocket:message-broker application-destination-prefix="/app">
        <websocket:stomp-endpoint path="/portfolio" />
            <websocket:sockjs/>
        </websocket:stomp-endpoint>
        <websocket:stomp-broker-relay prefix="/topic,/queue" />
    </websocket:message-broker>

</beans>
```

先前配置中的STOMP代理中继是一个Spring [`MessageHandler`](https://docs.spring.io/spring-framework/docs/5.3.1/javadoc-api/org/springframework/messaging/MessageHandler.html) ，它通过将消息转发到外部消息代理来处理消息。为此，它建立到代理的TCP连接，将所有消息转发给它，然后通过它们的WebSocket会话将从代理收到的所有消息转发给客户端。本质上，它充当双向转发消息的“中继”。

将`io.projectreactor.netty:reactor-netty`和`io.netty:netty-all` 依赖项添加到您的项目中以进行TCP连接管理。

此外，应用程序组件（例如HTTP请求处理方法，业务服务等）也可以将消息发送到代理中继，如“[发送消息”中所述](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#websocket-stomp-handle-send)，以将消息广播到订阅的WebSocket客户端。

实际上，代理中继可实现健壮且可伸缩的消息广播。

#### 4.4.10。连接到代理

STOMP代理中继器维护与代理的单个“系统” TCP连接。此连接仅用于源自服务器端应用程序的消息，而不用于接收消息。您可以为此连接配置STOMP凭据（即STOMP帧`login`和`passcode`标头）。这在XML名称空间和Java配置中都以`systemLogin`和 `systemPasscode`属性（默认值为`guest`和）公开`guest`。

STOMP代理中继还为每个连接的WebSocket客户端创建一个单独的TCP连接。您可以配置用于代表客户端创建的所有TCP连接的STOMP凭据。这在XML名称空间和Java配置中都以`clientLogin`和`clientPasscode`属性（默认值为`guest`和）公开`guest`。

  STOMP代理中继始终 在代表客户端转发给代理的每个帧上设置`login`和`passcode`标头`CONNECT`。因此，WebSocket客户端无需设置这些标头。他们被忽略。如“[身份验证”](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#websocket-stomp-authentication) 部分所述，WebSocket客户端应改为依靠HTTP身份验证来保护WebSocket端点并建立客户端身份。

STOMP代理中继还通过“系统” TCP连接向消息代理发送和从消息代理接收心跳。您可以配置发送和接收心跳的间隔（默认情况下，每个间隔为10秒）。如果与代理的连接断开，则代理中继每5秒继续尝试重新连接，直到成功。

`ApplicationListener<BrokerAvailabilityEvent>` 当与代理的“系统”连接丢失并重新建立时，任何Spring bean都可以实现以接收通知。例如，当没有活动的“系统”连接时，广播股票报价的股票报价服务可以停止尝试发送消息。

默认情况下，STOMP代理中继始终连接到同一主机和端口，如果连接断开，则根据需要重新连接。如果希望提供多个地址，则在每次尝试连接时，都可以配置地址供应商，而不是固定的主机和端口。以下示例显示了如何执行此操作：

```java
@Configuration
@EnableWebSocketMessageBroker
public class WebSocketConfig extends AbstractWebSocketMessageBrokerConfigurer {

    // ...

    @Override
    public void configureMessageBroker(MessageBrokerRegistry registry) {
        registry.enableStompBrokerRelay("/queue/", "/topic/").setTcpClient(createTcpClient());
        registry.setApplicationDestinationPrefixes("/app");
    }

    private ReactorNettyTcpClient<byte[]> createTcpClient() {
        return new ReactorNettyTcpClient<>(
                client -> client.addressSupplier(() -> ... ),
                new StompReactorNettyCodec());
    }
}
```

您还可以使用`virtualHost`属性配置STOMP代理中继。此属性的值设置为`host`每个`CONNECT`帧的标头，并且很有用（例如，在建立TCP连接的实际主机与提供基于云的STOMP服务的主机不同的云环境中）。

#### 4.4.11。点作为分隔符

将消息路由到`@MessageMapping`方法时，它们与匹配 `AntPathMatcher`。默认情况下，模式应使用斜杠（`/`）作为分隔符。这是Web应用程序中的良好约定，类似于HTTP URL。但是，如果您更习惯于消息传递约定，则可以切换为使用点（`.`）作为分隔符。

以下示例显示了如何在Java配置中执行此操作：

```java
@Configuration
@EnableWebSocketMessageBroker
public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {

    // ...

    @Override
    public void configureMessageBroker(MessageBrokerRegistry registry) {
        registry.setPathMatcher(new AntPathMatcher("."));
        registry.enableStompBrokerRelay("/queue", "/topic");
        registry.setApplicationDestinationPrefixes("/app");
    }
}
```

以下示例显示了与先前示例等效的XML配置：

```xml
<beans xmlns="http://www.springframework.org/schema/beans"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xmlns:websocket="http://www.springframework.org/schema/websocket"
        xsi:schemaLocation="
                http://www.springframework.org/schema/beans
                https://www.springframework.org/schema/beans/spring-beans.xsd
                http://www.springframework.org/schema/websocket
                https://www.springframework.org/schema/websocket/spring-websocket.xsd">

    <websocket:message-broker application-destination-prefix="/app" path-matcher="pathMatcher">
        <websocket:stomp-endpoint path="/stomp"/>
        <websocket:stomp-broker-relay prefix="/topic,/queue" />
    </websocket:message-broker>

    <bean id="pathMatcher" class="org.springframework.util.AntPathMatcher">
        <constructor-arg index="0" value="."/>
    </bean>

</beans>
```

之后，控制器可以使用点（`.`）作为`@MessageMapping`方法中的分隔符，如以下示例所示：

```java
@Controller
@MessageMapping("red")
public class RedController {

    @MessageMapping("blue.{green}")
    public void handleGreen(@DestinationVariable String green) {
        // ...
    }
}
```

客户端现在可以向发送消息`/app/red.blue.green123`。

在前面的示例中，我们没有更改“代理中继”上的前缀，因为这些前缀完全取决于外部消息代理。有关您使用的代理的信息，请参见STOMP文档页面，以查看其对目标标头支持的约定。

另一方面，“简单代理”确实依赖于configure `PathMatcher`，因此，如果切换分隔符，该更改也将应用于代理，以及代理将目标从消息匹配到订阅中的模式的方式。

#### 4.4.12。认证方式

每个通过WebSocket进行的STOMP消息传递会话均以HTTP请求开头。这可以是升级到WebSockets的请求（即WebSocket握手），或者在SockJS后备情况下，是一系列SockJS HTTP传输请求。

许多Web应用程序已经具有身份验证和授权来保护HTTP请求。通常，使用某种机制，例如登录页面，HTTP基本认证或其他方式，通过Spring Security对用户进行认证。经过身份验证的用户的安全上下文保存在HTTP会话中，并与同一基于cookie的会话中的后续请求关联。

因此，对于WebSocket握手或SockJS HTTP传输请求，通常已经存在可通过访问的经过身份验证的用户 `HttpServletRequest#getUserPrincipal()`。Spring会自动将该用户与为其创建的WebSocket或SockJS会话相关联，随后将其与通过用户标头在该会话上传输的所有STOMP消息相关联。

简而言之，一个典型的Web应用程序除了已经为安全起见，就不需要做任何事情。通过基于cookie的HTTP会话（然后与为该用户创建的WebSocket或SockJS会话相关联）维护的安全上下文在HTTP请求级别对用户进行身份验证，并导致在每个`Message`流经的用户头上标记用户头应用程序。

请注意，STOMP协议在帧上确实有`login`和`passcode`标头`CONNECT`。这些最初是设计用于并且仍然需要的，例如，基于TCP的STOMP。但是，对于默认情况下，对于基于WebSocket的STOMP，Spring会在STOMP协议级别忽略授权标头，并假定该用户已经在HTTP传输级别进行了身份验证，并期望WebSocket或SockJS会话包含经过身份验证的用户。

 Spring Security提供了 [WebSocket子协议授权](https://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/#websocket) ，该[授权](https://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/#websocket)使用`ChannelInterceptor`来根据消息中的用户标头对消息进行授权。而且，Spring Session提供了 [WebSocket集成](https://docs.spring.io/spring-session/docs/current/reference/html5/#websocket) ，以确保当WebSocket会话仍处于活动状态时，用户HTTP会话不会过期。

#### 4.4.13。令牌认证

[Spring Security OAuth](https://github.com/spring-projects/spring-security-oauth) 支持基于令牌的安全性，包括JSON Web令牌（JWT）。可以将其用作Web应用程序中的身份验证机制，包括上一节中所述的WebSocket交互中的STOMP（即，通过基于cookie的会话来维护身份）。

同时，基于cookie的会话并非总是最合适的（例如，在不维护服务器端会话的应用程序中或在通常使用标头进行身份验证的移动应用程序中）。

该[WebSocket协议，RFC 6455](https://tools.ietf.org/html/rfc6455#section-10.5) “并没有规定任何具体的方式，服务器可以在网页套接字握手期间验证客户端。” 但是，实际上，浏览器客户端只能使用标准身份验证标头（即基本HTTP身份验证）或cookie，而不能（例如）提供自定义标头。同样，SockJS JavaScript客户端也不提供通过SockJS传输请求发送HTTP标头的方法。请参阅 [sockjs-client问题196](https://github.com/sockjs/sockjs-client/issues/196)。相反，它确实允许发送可用于发送令牌的查询参数，但这有其自身的缺点（例如，令牌可能会不经意间随服务器日志中的URL一起记录）。

前面的限制适用于基于浏览器的客户端，不适用于基于Spring Java的STOMP客户端，该客户端确实支持通过WebSocket和SockJS请求发送标头。

因此，希望避免使用cookie的应用程序可能没有在HTTP协议级别进行身份验证的任何好的替代方法。他们可能更喜欢在STOMP消息传递协议级别使用标头进行身份验证，而不是使用cookie。这样做需要两个简单的步骤：

1. 使用STOMP客户端在连接时传递身份验证头。
2. 使用来处理身份验证标头`ChannelInterceptor`。

下一个示例使用服务器端配置来注册自定义身份验证拦截器。请注意，拦截器仅需要认证并在CONNECT上设置用户标头`Message`。Spring记录并保存经过身份验证的用户，并将其与同一会话上的后续STOMP消息相关联。以下示例显示了如何注册自定义身份验证拦截器：

```java
@Configuration
@EnableWebSocketMessageBroker
public class MyConfig implements WebSocketMessageBrokerConfigurer {

    @Override
    public void configureClientInboundChannel(ChannelRegistration registration) {
        registration.interceptors(new ChannelInterceptor() {
            @Override
            public Message<?> preSend(Message<?> message, MessageChannel channel) {
                StompHeaderAccessor accessor =
                        MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class);
                if (StompCommand.CONNECT.equals(accessor.getCommand())) {
                    Authentication user = ... ; // access authentication header(s)
                    accessor.setUser(user);
                }
                return message;
            }
        });
    }
}
```

另外，请注意，目前，当您使用Spring Security的消息授权时，需要确保在`ChannelInterceptor`Spring Security之前订购身份验证配置。最好通过在`WebSocketMessageBrokerConfigurer`标 有的自己的实现中声明自定义拦截器来完成此操作`@Order(Ordered.HIGHEST_PRECEDENCE + 99)`。

#### 4.4.14。用户目的地

应用程序可以发送针对特定用户的消息，并且Spring的STOMP支持可以识别`/user/`为此目的加上前缀的目标。例如，客户端可能订阅了`/user/queue/position-updates`目的地。该目标由处理，`UserDestinationMessageHandler`并转换为用户会话唯一的目标（例如`/queue/position-updates-user123`）。这提供了订阅通用命名目的地的便利，同时确保与预订相同目的地的其他用户不发生冲突，以便每个用户都可以接收唯一的库存头寸更新。

在发送方，可以将消息发送到目的地（例如） `/user/{username}/queue/position-updates`，然后将其转换`UserDestinationMessageHandler`为一个或多个目的地，每个与用户相关联的会话都将其翻译成一个或多个目的地。这使应用程序内的任何组件都可以发送针对特定用户的消息，而不必知道他们的姓名和通用目的地。注释和消息传递模板也支持此功能。

消息处理方法可以通过`@SendToUser`注释将消息发送给与正在处理的消息相关联的用户（在类级别上也支持共享一个公共目的地），如以下示例所示：

```java
@Controller
public class PortfolioController {

    @MessageMapping("/trade")
    @SendToUser("/queue/position-updates")
    public TradeResult executeTrade(Trade trade, Principal principal) {
        // ...
        return tradeResult;
    }
}
```

如果用户具有多个会话，则默认情况下，所有订阅给定目标的会话都是目标。但是，有时可能仅需要将发送正在处理的消息的会话作为目标。您可以通过将`broadcast`属性设置为false来实现，如以下示例所示：

```java
@Controller
public class MyController {

    @MessageMapping("/action")
    public void handleAction() throws Exception{
        // raise MyBusinessException here
    }

    @MessageExceptionHandler
    @SendToUser(destinations="/queue/errors", broadcast=false)
    public ApplicationError handleException(MyBusinessException exception) {
        // ...
        return appError;
    }
}
```

尽管用户目的地通常暗指经过身份验证的用户，但这并不是严格要求的。不与已认证用户关联的WebSocket会话可以订阅用户目的地。在这种情况下，`@SendToUser`注释的行为与完全相同`broadcast=false`（也就是说，仅针对发送正在处理的消息的会话）。

您可以从任何应用程序组件向用户目标发送消息，例如`SimpMessagingTemplate`通过注入Java配置或XML名称空间创建的消息。（`brokerMessagingTemplate`如果需要使用限定，则必须使用Bean名称`@Qualifier`。）下面的示例演示了如何做到这一点：

```java
@Service
public class TradeServiceImpl implements TradeService {

    private final SimpMessagingTemplate messagingTemplate;

    @Autowired
    public TradeServiceImpl(SimpMessagingTemplate messagingTemplate) {
        this.messagingTemplate = messagingTemplate;
    }

    // ...

    public void afterTradeExecuted(Trade trade) {
        this.messagingTemplate.convertAndSendToUser(
                trade.getUserName(), "/queue/position-updates", trade.getResult());
    }
}
```

 将用户目标与外部消息代理一起使用时，应查看代理文档以了解如何管理非活动队列，以便在用户会话结束时，将删除所有唯一的用户队列。例如，当您使用目的地时，RabbitMQ将创建自动删除队列`/exchange/amq.direct/position-updates`。因此，在这种情况下，客户端可以订阅`/user/exchange/amq.direct/position-updates`。同样，ActiveMQ具有 用于清除非活动目标的[配置选项](https://activemq.apache.org/delete-inactive-destinations.html)。

在多应用程序服务器方案中，由于用户连接到其他服务器，因此用户目的地可能无法解析。在这种情况下，您可以配置目标以广播未解决的消息，以便其他服务器可以尝试。这可以通过做`userDestinationBroadcast`属性 `MessageBrokerRegistry`在Java配置和`user-destination-broadcast`该属性`message-broker`的XML元素。

#### 4.4.15。消息顺序

来自代理的消息被发布到`clientOutboundChannel`，从那里被写入WebSocket会话。由于该通道由`ThreadPoolExecutor`支持，因此消息将在不同的线程中处理，并且客户端接收到的结果序列可能与发布的确切顺序不匹配。

如果这是一个问题，请启用该`setPreservePublishOrder`标志，如以下示例所示：

```java
@Configuration
@EnableWebSocketMessageBroker
public class MyConfig implements WebSocketMessageBrokerConfigurer {

    @Override
    protected void configureMessageBroker(MessageBrokerRegistry registry) {
        // ...
        registry.setPreservePublishOrder(true);
    }

}
```

以下示例显示了与先前示例等效的XML配置：

```xml
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:websocket="http://www.springframework.org/schema/websocket"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/websocket
        https://www.springframework.org/schema/websocket/spring-websocket.xsd">

    <websocket:message-broker preserve-publish-order="true">
        <!-- ... -->
    </websocket:message-broker>

</beans>
```

设置该标志后，同一客户端会话中的消息将一次发布到`clientOutboundChannel`一个客户端会话中 ，从而保证了发布的顺序。请注意，这会产生很小的性能开销，因此，只有在需要时才应启用它。

#### 4.4.16。大事记

`ApplicationContext`通过实现Spring的`ApplicationListener`接口，可以发布几个事件，并且可以接收这些事件：

- `BrokerAvailabilityEvent`：指示代理何时可用或不可用。当“简单”代理在启动时立即可用并保持运行状态时，STOMP“代理中继”可能会失去与功能齐全的代理的连接（例如，如果代理重新启动）。代理中继具有重新连接逻辑，并在代理返回时重新建立与代理的“系统”连接。因此，只要状态从连接变为断开，反之亦然，就会发布此事件。使用的组件`SimpMessagingTemplate`应预订此事件，并避免在代理不可用时避免发送消息。无论如何，它们应该准备`MessageDeliveryException` 在发送消息时进行处理。
- `SessionConnectEvent`：在收到新的STOMP CONNECT时开始发布，以指示新的客户端会话的开始。该事件包含代表连接的消息，包括会话ID，用户信息（如果有）以及客户端发送的所有自定义标头。这对于跟踪客户端会话很有用。预订此事件的组件可以使用`SimpMessageHeaderAccessor`或 包装包含的消息`StompMessageHeaderAccessor`。
- `SessionConnectedEvent`：`SessionConnectEvent`在代理发送一个STOMP CONNECTED帧以响应CONNECT之后不久发布。此时，可以认为STOMP会话已完全建立。
- `SessionSubscribeEvent`：在收到新的STOMP SUBSCRIBE时发布。
- `SessionUnsubscribeEvent`：在收到新的STOMP UNSUBSCRIBE时发布。
- `SessionDisconnectEvent`：在STOMP会话结束时发布。DISCONNECT可能是从客户端发送的，也可能在WebSocket会话关闭时自动生成。在某些情况下，每个会话多次发布该事件。组件应与多个断开事件有关。

#### 4.4.17。拦截

[事件](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#websocket-stomp-appplication-context-events)提供有关STOMP连接生命周期的通知，但不提供每条客户端消息的通知。应用程序还可以注册一个， `ChannelInterceptor`以拦截处理链中任何部分的任何消息。以下示例显示如何拦截来自客户端的入站消息：

```java
@Configuration
@EnableWebSocketMessageBroker
public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {

    @Override
    public void configureClientInboundChannel(ChannelRegistration registration) {
        registration.interceptors(new MyChannelInterceptor());
    }
}
```

定制`ChannelInterceptor`可以使用`StompHeaderAccessor`或`SimpMessageHeaderAccessor` 访问有关消息的信息，如以下示例所示：

```java
public class MyChannelInterceptor implements ChannelInterceptor {

    @Override
    public Message<?> preSend(Message<?> message, MessageChannel channel) {
        StompHeaderAccessor accessor = StompHeaderAccessor.wrap(message);
        StompCommand command = accessor.getStompCommand();
        // ...
        return message;
    }
}
```

应用程序还可以实现`ExecutorChannelInterceptor`，这是`ChannelInterceptor`在其中处理消息的线程中带有回调的子接口。虽然`ChannelInterceptor`对发送到通道的每个消息都调用一次， 但`ExecutorChannelInterceptor`在每个`MessageHandler` 订阅了该通道消息的线程中都提供了挂钩。

请注意，`SessionDisconnectEvent`如前所述，DISCONNECT消息可以来自客户端，也可以在关闭WebSocket会话时自动生成。在某些情况下，拦截器可能会在每个会话中多次拦截此消息。关于多个断开事件，组件应该是幂等的。

#### 4.4.18。STOMP客户端

Spring提供了一个基于WebSocket的STOMP客户端和一个基于TCP的STOMP客户端。

首先，您可以创建和配置`WebSocketStompClient`，如以下示例所示：

```java
WebSocketClient webSocketClient = new StandardWebSocketClient();
WebSocketStompClient stompClient = new WebSocketStompClient(webSocketClient);
stompClient.setMessageConverter(new StringMessageConverter());
stompClient.setTaskScheduler(taskScheduler); // for heartbeats
```

在前面的示例中，您可以替换`StandardWebSocketClient`为`SockJsClient`，因为这也是的实现`WebSocketClient`。在`SockJsClient`可以使用基于HTTP的WebSocket或运输作为后备。有关更多详细信息，请参见 [`SockJsClient`](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#websocket-fallback-sockjs-client)。

接下来，您可以建立连接并为STOMP会话提供处理程序，如以下示例所示：

```java
String url = "ws://127.0.0.1:8080/endpoint";
StompSessionHandler sessionHandler = new MyStompSessionHandler();
stompClient.connect(url, sessionHandler);
```

会话准备就绪后，将通知处理程序，如以下示例所示：

```java
public class MyStompSessionHandler extends StompSessionHandlerAdapter {

    @Override
    public void afterConnected(StompSession session, StompHeaders connectedHeaders) {
        // ...
    }
}
```

建立会话后，可以发送任何有效负载，并使用configure序列化有效负载`MessageConverter`，如以下示例所示：

```java
session.send("/topic/something", "payload");
```

您还可以订阅目的地。这些`subscribe`方法需要用于订阅消息的处理程序，并返回`Subscription`可用于取消订阅的句柄。对于每个收到的消息，处理程序可以指定`Object`有效负载应反序列化的目标 类型，如以下示例所示：

```java
session.subscribe("/topic/something", new StompFrameHandler() {

    @Override
    public Type getPayloadType(StompHeaders headers) {
        return String.class;
    }

    @Override
    public void handleFrame(StompHeaders headers, Object payload) {
        // ...
    }

});
```

要启用STOMP心跳，您可以配置`WebSocketStompClient`a`TaskScheduler` 并有选择地自定义心跳间隔（写不活动（导致发送心跳）需要10秒，读不活动（要关闭连接）需要10秒）。

`WebSocketStompClient`仅在不活动时（即未发送其他消息时）发送心跳。使用外部代理时，这可能会带来挑战，因为具有非代理目标的消息表示活动，但实际上并未转发给代理。在这种情况下，您可以`TaskScheduler` 在初始化[外部代理](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#websocket-stomp-handle-broker-relay)时进行配置，以确保在仅发送具有非代理目标的消息时也将心跳转发到代理。

#### 4.4.19。WebSocket范围

每个WebSocket会话都有一个属性映射。该映射作为标头附加到入站客户端消息，可以通过控制器方法进行访问，如以下示例所示：

```java
@Controller
public class MyController {

    @MessageMapping("/action")
    public void handle(SimpMessageHeaderAccessor headerAccessor) {
        Map<String, Object> attrs = headerAccessor.getSessionAttributes();
        // ...
    }
}
```

您可以在`websocket`范围中声明一个Spring管理的bean 。您可以将WebSocket范围的bean注入控制器和在上注册的所有通道拦截器中`clientInboundChannel`。这些通常是单例，并且比任何单独的WebSocket会话寿命更长。因此，您需要对作用域WebSocket的bean使用作用域代理模式，如以下示例所示：

```java
@Component
@Scope(scopeName = "websocket", proxyMode = ScopedProxyMode.TARGET_CLASS)
public class MyBean {

    @PostConstruct
    public void init() {
        // Invoked after dependencies injected
    }

    // ...

    @PreDestroy
    public void destroy() {
        // Invoked when the WebSocket session ends
    }
}

@Controller
public class MyController {

    private final MyBean myBean;

    @Autowired
    public MyController(MyBean myBean) {
        this.myBean = myBean;
    }

    @MessageMapping("/action")
    public void handle() {
        // this.myBean from the current WebSocket session
    }
}
```

与任何自定义作用域一样，Spring`MyBean`首次在控制器中对其进行访问时会初始化一个新实例，并将该实例存储在WebSocket会话属性中。随后将返回相同的实例，直到会话结束。WebSocket范围的bean调用了所有Spring生命周期方法，如前面的示例所示。

#### 4.4.20。性能

关于性能，没有万能药。影响它的因素很多，包括消息的大小和数量，应用程序方法是否执行需要阻止的工作以及外部因素（例如网络速度和其他问题）。本部分的目的是提供可用配置选项的概述，以及有关如何进行扩展的一些想法。

在消息传递应用程序中，消息通过通道传递以进行异步执行，并由线程池支持。配置这样的应用程序需要对通道和消息流有充分的了解。因此，建议查看[消息流](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#websocket-stomp-message-flow)。

最明显的起点是配置支持`clientInboundChannel`和`clientOutboundChannel`。默认情况下，两者都配置为可用处理器数量的两倍。

如果带注释的方法中的消息处理主要是受CPU限制的，则的线程数`clientInboundChannel`应保持接近处理器数。如果他们所做的工作更多地受到IO限制，并且需要阻塞或等待数据库或其他外部系统，则可能需要增加线程池大小。

`ThreadPoolExecutor` 具有三个重要属性：核心线程池大小，最大线程池大小，以及队列存储没有可用线程的任务的容量。

常见的混淆点是，配置核心池大小（例如10）和最大池大小（例如20）会导致线程池具有10到20个线程。实际上，如果将容量保留为其默认值Integer.MAX_VALUE，则由于所有其他任务都已排队，因此线程池永远不会超过核心池的大小。

请参阅的javadoc，`ThreadPoolExecutor`以了解这些属性如何工作并了解各种排队策略。

在`clientOutboundChannel`一边，它是所有关于发送消息的WebSocket客户端。如果客户端位于快速网络上，则线程数应保持接近可用处理器数。如果它们很慢或带宽很低，它们将花费更长的时间来消耗消息并给线程池增加负担。因此，必须增加线程池的大小。

尽管`clientInboundChannel`可以预测应用程序的工作量（毕竟，它是基于应用程序的工作），但是如何配置clientOutboundChannel却更加困难，因为它基于应用程序无法控制的因素。因此，有两个附加属性与消息发送有关：`sendTimeLimit` 和`sendBufferSizeLimit`。您可以使用这些方法来配置发送消息到客户端时允许发送多长时间以及可以缓冲多少数据。

通常的想法是，在任何给定时间，只能使用一个线程发送给客户端。同时，所有其他消息都将被缓冲，并且您可以使用这些属性来决定允许发送消息花费多长时间以及在此期间可以缓冲多少数据。有关其他重要信息，请参见XML模式的javadoc和文档。

以下示例显示了可能的配置：

```java
@Configuration
@EnableWebSocketMessageBroker
public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {

    @Override
    public void configureWebSocketTransport(WebSocketTransportRegistration registration) {
        registration.setSendTimeLimit(15 * 1000).setSendBufferSizeLimit(512 * 1024);
    }

    // ...

}
```

以下示例显示了与先前示例等效的XML配置：

```xml
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:websocket="http://www.springframework.org/schema/websocket"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/websocket
        https://www.springframework.org/schema/websocket/spring-websocket.xsd">

    <websocket:message-broker>
        <websocket:transport send-timeout="15000" send-buffer-size="524288" />
        <!-- ... -->
    </websocket:message-broker>

</beans>
```

您还可以使用前面显示的WebSocket传输配置来配置传入STOMP消息的最大允许大小。从理论上讲，WebSocket消息的大小几乎是无限的。实际上，WebSocket服务器施加了限制-例如，Tomcat 8K和Jetty 64K。因此，STOMP客户端（例如JavaScript [webstomp-client](https://github.com/JSteunou/webstomp-client) 等）在16K边界处拆分较大的STOMP消息，并将其作为多个WebSocket消息发送，这需要服务器进行缓冲和重新组装。

Spring的STOMP-over-WebSocket支持可以做到这一点，因此应用程序可以为STOMP消息配置最大大小，而与WebSocket服务器特定的消息大小无关。请记住，如有必要，将自动调整WebSocket消息的大小，以确保它们最多可以承载16K WebSocket消息。

以下示例显示了一种可能的配置：

```java
@Configuration
@EnableWebSocketMessageBroker
public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {

    @Override
    public void configureWebSocketTransport(WebSocketTransportRegistration registration) {
        registration.setMessageSizeLimit(128 * 1024);
    }

    // ...

}
```

以下示例显示了与先前示例等效的XML配置：

```xml
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:websocket="http://www.springframework.org/schema/websocket"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/websocket
        https://www.springframework.org/schema/websocket/spring-websocket.xsd">

    <websocket:message-broker>
        <websocket:transport message-size="131072" />
        <!-- ... -->
    </websocket:message-broker>

</beans>
```

关于扩展的重要一点涉及使用多个应用程序实例。当前，您不能使用简单的代理来做到这一点。但是，当您使用功能齐全的代理（例如RabbitMQ）时，每个应用程序实例都连接到代理，并且从一个应用程序实例广播的消息可以通过代理广播到通过任何其他应用程序实例连接的WebSocket客户端。

#### 4.4.21。监控方式

当您使用`@EnableWebSocketMessageBroker`或时`<websocket:message-broker>`，关键基础架构组件会自动收集统计信息和计数器，这些统计信息和计数器可提供对应用程序内部状态的重要了解。该配置还声明了一个类型为Bean的bean，该bean`WebSocketMessageBrokerStats`会将所有可用信息收集到一个地方，并且默认情况下`INFO`每30分钟将其记录在该级别一次。可以通过Spring将该bean导出到JMX `MBeanExporter`，以便在运行时进行查看（例如，通过JDK `jconsole`）。以下列表总结了可用信息：

- 客户端WebSocket会话

  当前指示当前有多少个客户端会话，并且通过WebSocket与HTTP流和轮询SockJS会话进一步细分计数。总指示已建立的会话总数。异常关闭连接失败已建立但在60秒内未收到任何消息后关闭的会话。这通常表示代理或网络问题。超过发送限制超过配置的发送超时或发送缓冲区限制后，会话将关闭，缓慢的客户端可能会发生该会话（请参阅上一节）。运输错误传输错误（例如无法读取或写入WebSocket连接或HTTP请求或响应）后，会话关闭。STOMP框架已处理的CONNECT，CONNECTED和DISCONNECT帧的总数，指示在STOMP级别上连接了多少个客户端。请注意，当会话异常关闭或客户端未发送DISCONNECT帧而关闭时，DISCONNECT计数可能会降低。

- STOMP经纪人接力

  TCP连接指示与代理建立了代表客户端WebSocket会话的TCP连接数。这应该等于客户端WebSocket会话的数量+ 1个用于从应用程序内部发送消息的附加共享“系统”连接。STOMP框架代表客户转发到代理或从代理接收的CONNECT，CONNECTED和DISCONNECT帧总数。请注意，无论客户端WebSocket会话如何关闭，DISCONNECT帧都会发送到代理。因此，较低的DISCONNECT帧计数表示代理正在主动关闭连接（可能是由于未及时到达的心跳，无效的输入帧或其他问题）。

- 客户入站通道

  来自支持该线程池的线程池的统计信息`clientInboundChannel` ，可深入了解传入消息处理的运行状况。此处排队的任务表明该应用程序可能太慢而无法处理消息。如果存在I / O绑定的任务（例如，慢速的数据库查询，对第三方REST API的HTTP请求等），请考虑增加线程池的大小。

- 客户出站通道

  来自支持该线程池的线程池的统计信息`clientOutboundChannel` ，可以深入了解向客户端广播消息的运行状况。这里排队的任务表明客户端太慢而无法使用消息。解决此问题的一种方法是增加线程池大小，以容纳并发慢速客户端的预期数量。另一个选择是减少发送超时和发送缓冲区大小限制（请参阅上一节）。

- SockJS任务计划程序

  来自SockJS任务调度程序的线程池的统计信息，用于发送心跳。请注意，在STOMP级别协商心跳时，将禁用SockJS心跳。

#### 4.4.22。测验

当您使用Spring的STOMP-over-WebSocket支持时，有两种主要的方法来测试应用程序。首先是编写服务器端测试以验证控制器的功能及其带注释的消息处理方法。第二个是编写涉及运行客户端和服务器的完整的端到端测试。

两种方法不是互斥的。相反，每个人在整体测试策略中都有自己的位置。服务器端测试更加集中，更易于编写和维护。另一方面，端到端集成测试更完整，测试更多，但是编写和维护它们的工作也更多。

服务器端测试的最简单形式是编写控制器单元测试。但是，这还不够有用，因为控制器所做的很多事情都取决于其注释。纯单元测试根本无法测试。

理想情况下，应该像在运行时一样调用被测控制器，就像使用Spring MVC Test框架测试处理HTTP请求的控制器的方法一样，即不运行Servlet容器而是依靠Spring框架来调用被测控制器。带注释的控制器。与Spring MVC Test一样，您有两种可能的选择，要么使用“基于上下文的”设置，要么使用“独立的”设置：

- 在Spring TestContext框架的帮助下加载实际的Spring配置，`clientInboundChannel`作为测试字段注入，并使用它发送消息以由控制器方法处理。
- 手动设置最低的Spring框架基础结构，以调用控制器（即`SimpAnnotationMethodMessageHandler`）并将控制器消息直接传递给它。

[在股票投资组合](https://github.com/rstoyanchev/spring-websocket-portfolio/tree/master/src/test/java/org/springframework/samples/portfolio/web) 样本应用程序的[测试](https://github.com/rstoyanchev/spring-websocket-portfolio/tree/master/src/test/java/org/springframework/samples/portfolio/web)中演示了这两种设置方案 。

第二种方法是创建端到端集成测试。为此，您需要以嵌入式模式运行WebSocket服务器并将其作为WebSocket客户端连接到该服务器，该客户端发送包含STOMP帧的WebSocket消息。 通过使用Tomcat作为嵌入式WebSocket服务器和用于测试目的的简单STOMP客户端，针对[股票投资组合](https://github.com/rstoyanchev/spring-websocket-portfolio/tree/master/src/test/java/org/springframework/samples/portfolio/web)样本应用程序的[测试](https://github.com/rstoyanchev/spring-websocket-portfolio/tree/master/src/test/java/org/springframework/samples/portfolio/web)也演示了这种方法。
